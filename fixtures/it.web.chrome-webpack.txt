The first two lines of your configuration are the mode (development or production) and devtool which controls how source maps are generated (source maps let you debug minified code more easily, you can read more about them here).
From there you have your entry and output blocks, in the entry block we define an entry point of app as the index.js file inside our static folder. The index.js file imports App, which presumably will import other components. At build time, webpack will follow that import tree, grab all the related JS files, and then bundle them.
Below the entry block, we have the output block. In the output block, we are telling webpack to bundle all of our files to a build folder in our current directory. Additionally, we are telling webpack that we want to follow the [name].js pattern so out output bundle should have the name app.js. Below entry and output we have a resolve block which just tells webpack to only look for and bundle files that end with js.
Now on to our plugins. The first plugin is our HTML webpack plugin which takes the base HTML file that we created in static, and then dynamically adds a title, meta and other info like links to our manifest file and generates this file at build time. The copy plugin is pretty simple, it just tells webpack to copy over our icons to the build folder at build time. Finally, our manifest plugin does basically the same thing as the HTML plugin but for our manifest, creating a manifest.json dynamically at build time and then adding it to our build folder at build time. You can achieve the same thing by adding an extra line to the copy plugin configuration to copy over the manifest, however, this plugin gives you some more control over what to put into the manifest which we will get to in subsequent parts.
Finally, we have our loaders, these loaders control the rules of how stuff should be bundled into our build bundle. It handles JS, CSS and image files.